<!DOCTYPE html>
<html>
<head>
  <style>
table {
  border-collapse :collapse;
  margin          :0px;
  text-align      :left;
  vertical-align  :top;
  color           :black;
  background-color:white;
}
ol {
  padding-top     :0px;
  margin-top      :0px;
  margin-bottom   :0px;
  padding-left    :30px;
}
#mute {
  color           :green;
}
#main {
  text-align      :center;
  font-family     :monospace;
  font-size       :10px;
}
#Illustration {
  text-align      :center;
}
#part {
  vertical-align  :top;
  border          :1px solid black;
  border-collapse :collapse;
}
#Commentary {
  border          :1px solid black;
  border-collapse :collapse;
  text-align      :left;
  vertical-align  :top;
  color           :white;
  background-color:black;
}
#header1 {
  font-size       :20px;
}
#header2 {
  font-size       :18px;
}
#header2 {
  font-size       :16px;
}
#header2 {
  font-size       :14px;
}
  </style>
  <script src="wiki.js"></script>
  <script type="text/javascript">

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
(function(w,d) {

  'use strict';

  // Include specializations
  // Both patterns need work because extra spaces appear in the output.
  w.wikiappend([
    'wikipedia',
    /\!w\s*(.*)\s*\|\s*(.*)\s*w\!/g,
    '<a href="https://en.wikipedia.org/wiki/$1" onmouseover="window.paper.comment.$1()">$2</a>',
    '!w a | b w!',
    '<a href="https://en.wikipedia.org/wiki/a" onmouseover="window.paper.comment.a()">b</a>'
    ]);
  w.wikiappend([
    'mouseover',
    /!:\s*([^\,]*)\s*\,\s*([^:]*)\s*:!/g,
    '<a href="" onmouseover="window.paper.comment.$1()">$2</a>',
    '!: a, b :!',
    '<a href="" onmouseover="window.paper.comment.a()">b</a>'
    ]);

  // Here Document function
  function HERE(f) { return f.toString().split('\n').slice(1,-1).join('\n'); }
  // Enable self-reference and wikipedia reference
  // Enable multiple chained onload handlers
  function pushEvent(func) {
    var oldonload = window.onload;
    if (typeof window.onload != 'function') {
      window.onload = func;
    } else {
      window.onload = function() {
        if (oldonload) {
          oldonload();
        }
        func();
      }
    }
  }

  // LOCAL DATA ///////////////////////////////////////////////////////////////

  // Two top level branch namespaces off of window are reasonable.
  w.html          = {};   // Control data for generating comment in HTML
  w.paper         = {};   // Content of the scientific paper

  // Secondary html control data
  w.html.speaker  = {};   // Sound to exemplify pulse rate changes
  w.html.canvas   = {};   // Control data for generating images on the canvas
  w.html.image    = {};   // Images of paper authors

  // Enable syntactic sugar accessors to the two namespaces.
  var html    = w.html;
  var paper   = w.paper;
  var speaker = html.speaker;
  var canvas  = html.canvas;
  var image   = html.image;

  paper.comment = {};   // An array of call-by-name comment fill functions.

  var comment = paper.comment;

  // Secondary paper content data
  paper.who = {
    authors:{
      'Humberto_Maturana':'H. Maturana',
      'Jerome_Lettvin':'J. Y. Lettvin',
      'Walter_Pitts':'W. H. Pitts',
      'Warren_McCulloch':'W. S. McCulloch'
    }, commenters:{
      'Jonathan_Lettvin':'Jonathan D. Lettvin'
    }
  };
  paper.where = {
    'RLE':'(Research Laboratory of Electronics, M.I.T. Cambridge, MA)'
  };

  // CONTROL DATA /////////////////////////////////////////////////////////////
  canvas.Edge     = 255;
  canvas.Line     = 1;
  canvas.Tick     = 10;
  canvas.Z        = [];
  canvas.Zeros    = 3;
  canvas.Diag     = canvas.Tick / Math.sqrt(2.0);
  canvas.Epsilon  = canvas.Line / 2;
  canvas.Gap      = canvas.Edge / 8;
  canvas.Color    = {black:"#000000", gray:"#777777", white:"#EEEEEE" };
  canvas.Showing  = [];
  canvas.Z0coefficient = 1.2196698912665045;
  canvas.X0 = canvas.Y0 = canvas.Edge / 2;

  for (var author in paper.who.authors) {
    image[author]  = new Image();
    image[author].src = author + '.jpg';
  }
  for (var facility in paper.where) {
    image[facility]  = new Image();
    image[facility].src = facility + '.jpg';
  }
  for (var commenter in paper.who.commenters) {
    image[commenter]  = new Image();
    image[commenter].src = commenter + '.jpg';
  }

  // PAPER CONTENT ////////////////////////////////////////////////////////////
  //___________________________________________________________________________
  paper.Title = HERE(function() {/*
== HOW SEEN MOVEMENT APPEARS IN^^^THE FROG'S OPTIC NERVE ==
*/});
  //___________________________________________________________________________
  paper.Caption = "Neutral Gray Background";
  //___________________________________________________________________________
  paper.Citation  = HERE(function() {/*
Federation Proceedings Volume 18 Number 1^^^
March 1959 Pages 393 and 354.^^^
*/});

  for (var author in paper.who.authors) {
    paper.Citation += '!w' + author + '|' + paper.who.authors[author] + 'w!\n';
  }
  paper.Citation += '^^^\n<a href="http://www.rle.mit.edu/">RLE</a>';

  for (var facility in paper.where) {
    paper.Citation += '!w' + facility + '|' + paper.where[facility] + 'w!\n';
  }

  //___________________________________________________________________________
  paper.Illustration = HERE(function() {/*
!wJonathan_Lettvin|Jonathan D. Lettvinw!
(<a href="http://jonathan.lettvin.com">(home)</a>),
comments 20160322^^^
with images against a !:Neutral,Neutral Gray Background:!
*/});
  //___________________________________________________________________________
  paper.PartI_title = HERE(function() {/*
=== Part I (page 393) ===
*/})
//___________________________________________________________________________
  paper.PartI_body = HERE(function() {/*
___The receptive field of a single !:Fiber,optic nerve fiber:!
(plotted by the on and off responses to small fixed spots)
is often divisible into !:Concentric,concentric zones:!
This suggests that the response of the fiber to a moving spot
may be !:Polar,polar:! with respect to a !:Point,reference point:!
in the receptive field.
Movement is indeed polarly encoded and there exist at least
the following four types of fibers whose rate of firing depends on
the !:Centrifugal,centrifugal:! component of a movement
with respect to !:Point,some point:! internal to the receptive field
(!:Centripetal,centripetal:! and tangential movements never cause discharge):
# Some fibers have wide receptive fields and low sensitivity.\
Of these some prefer the moving object !:Darker,darker:! than background,\
others prefer it !:Lighter,lighter:!.
# A second group has !:Constricted,constricted:! fields and high sensitivity.
# A third set shows a directional !:Weighting,heavy weighting:! of the response.
# A fourth kind has !:Annular,annular fields:!.
A fifth variety measures inversely
the average intensity of !:Illumination,illumination:! in a region.
Its maximum rate is in the dark.
*/});
  //___________________________________________________________________________
  paper.PartII_title = HERE(function() {/*
=== Part II (page 354) ===
*/});
  //___________________________________________________________________________
  paper.PartII_body = HERE(function() {/*
___The coding of movement described in Part I
suggests that the frog's eye is designed
(at least for land operation)
to abstract the vector and size of a moving object
and extrapolate the path.
Because our evidence implies that there exists a coordinate system
built into the retina and that the coding allows coordinates and velocity
to arise from general operations on the whole output of the optic nerve,
we propose some alternative guesses to account for
<a href="https://en.wikipedia.org/wiki/Roger_Wolcott_Sperry">Sperry's</a>
results on dislocated eyes.
We do not propose that his notion of specific reconnection is wrong
but that it is not necessary.^^^
___We also present the law by which there is a point-to-point correspondence
from receptors to optic nerve, vis.,
if an object is moved within the visual field in a !:Circular,circular:! path
of any !:Diameter,diameter:! the only fibers that show !:Response,no response:!
at any time are those that have the centers of their receptive fields
at the !:Center,center:! of the circle described.
*/});

  html.Paper = function() {
    var elements = [
      'Title',
      'Citation',
      'Illustration',
      'PartI_title',
      'PartI_body',
      'PartII_title',
      'PartII_body'
    ];
    for (var element of elements) {
      d.getElementById(element).innerHTML = w.markdown(paper[element]);
    }
  };

  //###########################################################################
  canvas.drawLine = function(xy1, xy2, color, width) {
    var ctx = canvas.ctx;
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.moveTo(xy1[0], xy1[1]);
    ctx.lineTo(xy2[0], xy2[1]);
    ctx.stroke();
  };

  //###########################################################################
  canvas.drawCircle = function(xycenter, radius, color, width) {
    var ctx = canvas.ctx;
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.arc(xycenter[0], xycenter[1], radius, 0, 2*Math.PI);
    ctx.stroke();
  };

  //###########################################################################
  // Neutral gray background
  canvas.Neutral = function() {
    var ctx = canvas.ctx;
    ctx.fillStyle = canvas.Color.gray;
    ctx.fillRect(0,0,255,255);
  };

  //###########################################################################
  canvas.Center = function(radius) {
    var ctx = canvas.ctx;
    console.log('Center');

    radius = radius || 5;

    canvas.drawLine([0,0], [254,254], '#ff0000', canvas.Line);
  };

  //###########################################################################
  // Concentric Rings
  canvas.Ring = function(radius) {
    if (!radius) {
      for (var z of canvas.Z) canvas.Ring(z);
    } else {
      var ctx = canvas.ctx;
      var center = [canvas.X0, canvas.Y0];
      var epsilon = canvas.Epsilon;
      var outer = radius+epsilon;
      var inner = radius-epsilon;

      // Outer adjacent ring
      canvas.drawCircle(center, outer, canvas.Color.black, canvas.Line);
      // Inner adjacent ring
      canvas.drawCircle(center, inner, canvas.Color.white, canvas.Line);
    }
  };

  //###########################################################################
  // Polar axes
  canvas.Polar = function() {
    var ctx = canvas.ctx;
    var color = canvas.Color.black;
    var ctrl = canvas;
    var X0 = ctrl.X0, Y0 = ctrl.Y0;
    var Tick = ctrl.Tick, Edge = ctrl.Edge, Diag = ctrl.Diag;
    var Showing = ctrl.Showing;

    // Cartesian axes
    canvas.drawLine([X0, 0], [X0, Edge], color, canvas.Line);
    canvas.drawLine([0, Y0], [Edge, Y0], color, canvas.Line);

    // Cartesian tick marks
    var t = 1.7;
    for (var i=0; i < X0; i += Tick) {
      // Y axis ticks
      canvas.drawLine([X0-t, Y0+i], [X0+t, Y0+i], color, canvas.Line);
      canvas.drawLine([X0-t, Y0-i], [X0+t, Y0-i], color, canvas.Line);

      // X axis ticks
      canvas.drawLine([X0+i, Y0-t], [X0+i, Y0+t], color, canvas.Line);
      canvas.drawLine([X0-i, Y0-t], [X0-i, Y0+t], color, canvas.Line);
    }

    // Diagonal axes
    canvas.drawLine([0,         0], [Edge, Edge], color, canvas.Line);
    canvas.drawLine([0, Edge], [Edge,         0], color, canvas.Line);

    // Diagonal tick marks
    var t = 1.2;
    for (var i=0; i < X0; i += Diag) {
      // Down Right axis ticks
      canvas.drawLine([X0+i-t, Y0+i+t], [X0+i+t, Y0+i-t], color, canvas.Line);
      canvas.drawLine([X0-i-t, Y0-i+t], [X0-i+t, Y0-i-t], color, canvas.Line);

      // Down Left axis ticks
      canvas.drawLine([X0+i-t, Y0-i-t], [X0+i+t, Y0-i+t], color, canvas.Line);
      canvas.drawLine([X0-i-t, Y0+i-t], [X0-i+t, Y0+i+t], color, canvas.Line);
    }
  };

  // FILL FUNCTION ////////////////////////////////////////////////////////////
  //___________________________________________________________________________
  canvas.fill = function() {
    var ctx = document.getElementById("illustration").getContext("2d");
    ctx.globalCompositeOperation="source-over";
    canvas.ctx = ctx;

    // Prepare the zeros array with the most recent coefficient.
    var Z0 = canvas.Z0coefficient * canvas.Gap;
    canvas.Z = [Z0];
    for (var z = 1; z < canvas.Zeros; z++) canvas.Z.push(Z0 + z * canvas.Gap);

    // These are the image component functions in alphabetical order.
    canvas.callable = {
      Annular         :canvas.Annular,
      Center          :canvas.Center,
      Centrifugal     :canvas.Centrifugal,
      Centripetal     :canvas.Centripetal,
      Circular        :canvas.Circular,
      Concentric      :canvas.Concentric,
      Constricted     :canvas.Constricted,
      Darker          :canvas.Darker,
      Diameter        :canvas.Diameter,
      Fiber           :canvas.Fiber,
      Illumination    :canvas.Illumination,
      Lighter         :canvas.Lighter,
      Neutral         :canvas.Neutral,
      Point           :canvas.Point,
      Polar           :canvas.Polar,
      PSF             :canvas.PSF,
      Response        :canvas.Response,
      Ring            :canvas.Ring,
      Weighting       :canvas.Weighting,

      Humberto_Maturana :canvas.Humberto_Maturana,
      Jerome_Lettvin    :canvas.Jerome_Lettvin,
      Jonathan_Lettvin  :canvas.Jonathan_Lettvin,
      Walter_Pitts      :canvas.Walter_Pitts,
      Warren_McCulloch  :canvas.Warren_McCulloch,

      RLE               :canvas.RLE,
    };

    // For each element of Showing, in order, add components to canvas.
    for (var fun in canvas.callable) {
      if (-1 != canvas.Showing.indexOf(fun)) {
        //console.log(fun);
        canvas.callable[fun]();
      }
    }

    html.Paper();
  };

  // COMMENT SERVICE FUNCTION (Used by call-by-name paper.comment functions)
  //___________________________________________________________________________
  html.Comment = function(caption, doc, visible) {
    d.getElementById('Caption').innerHTML = caption;
    d.getElementById('Commentary').innerHTML = w.markdown(doc);
    canvas.Showing = [];
    for (var i = 0; i < visible.length; i++) {
      canvas.Showing.push(visible[i]);
    }
    canvas.fill();
  };

  // Call-by-name comment fill functions //////////////////////////////////////
  //___________________________________________________________________________
  comment.Neutral = function() { var doc = HERE(function() {/*
== Neutral Gray ==
=== Why is this needed? ===
___Photoreceptors respond to changes in photon flux.
The change may be an increase or decrease of flux.
Successful modeling of flux changes in this paper
requires the ability to represent both types of flux change.
A neutral gray background enables the display of
objects both brighter and darker than the background.
=== Future Modeling ===
___This has consequence in modeling retinal functions
as described in additional papers.
    */});
    html.Comment('Neutral Gray Background', doc, ['Neutral']);
  };
  //___________________________________________________________________________
  comment.Concentric = function() { var doc = HERE(function() {/*
== Concentric Zones ==
=== When are signals generated? ===
Responses accompany crossing from inside to outside an annulus.
Concentric zones are proposed here as bounded by Airy zeros of
the
!:PSF,PSF:!
(Point Spread Function) for a monochromatic point source.
    */});
    html.Comment('Concentric Airy Zeros', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Polar = function() { var doc = HERE(function() {/*
Polar axes illustrate equidistance from center of concentric zone boundaries.
    */});
    html.Comment('Polar axes', doc, ['Neutral', 'Polar', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Center = function() { var doc = HERE(function() {/*
Center 
    */});
    html.Comment('center', doc, ['Neutral', 'Ring', 'Center']);
  };
  //___________________________________________________________________________
  comment.Centrifugal = function() { var doc = HERE(function() {/*
Centrifugal 
    */});
    html.Comment('Centrifugal motion', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.PSF = function() { var doc = HERE(function() {/*
Point Spread Function
    */});
    html.Comment('Point Spread Function', doc, ['Neutral']);
  };
  //___________________________________________________________________________
  comment.Point = function() { var doc = HERE(function() {/*
Point 
    */});
    html.Comment('Point', doc, ['Neutral']);
  };
  //___________________________________________________________________________
  comment.Centripetal = function() { var doc = HERE(function() {/*
Centripetal 
    */});
    html.Comment('Centripetal', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Darker = function() { var doc = HERE(function() {/*
Darker 
    */});
    html.Comment('Dark object motion', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Lighter = function() { var doc = HERE(function() {/*
Lighter 
    */});
    html.Comment('Light object motion', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Constricted = function() { var doc = HERE(function() {/*
Constricted 
    */});
    html.Comment('Constricted fields', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Weighting = function() { var doc = HERE(function() {/*
Weighting 
    */});
    html.Comment('Directional weighting', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Annular = function() { var doc = HERE(function() {/*
Annular 
    */});
    html.Comment('Annular fields', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Illumination = function() { var doc = HERE(function() {/*
Illumination 
    */});
    html.Comment('Inverse average intensity', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Circular = function() { var doc = HERE(function() {/*
Circular 
    */});
    html.Comment('Circular motion', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Fiber = function() { var doc = HERE(function() {/*
Fiber 
    */});
    html.Comment('Fiber: Ganglion cell axon', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Diameter = function() { var doc = HERE(function() {/*
Diameter 
    */});
    html.Comment('Invariant to diameter', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Response = function() { var doc = HERE(function() {/*
Response 
    */});
    html.Comment('No response at center', doc, ['Neutral', 'Ring']);
  };
  //___________________________________________________________________________
  comment.Humberto_Maturana  = function() { var doc = HERE(function() {/*
Humberto Maturana 
    */});
    html.Comment('Maturana', doc, ['Neutral']);
    var ctx = canvas.ctx;
    ctx.drawImage(image['Humberto_Maturana'], 0, 0);
  };
  //___________________________________________________________________________
  comment.Jerome_Lettvin  = function() { var doc = HERE(function() {/*
Jerome Y. Lettvin
    */});
    html.Comment('Lettvin', doc, ['Neutral']);
    var ctx = canvas.ctx;
    ctx.drawImage(image['Jerome_Lettvin'], 0, 0);
  };
  //___________________________________________________________________________
  comment.Walter_Pitts  = function() { var doc = HERE(function() {/*
Walter Pitts
    */});
    html.Comment('Pitts', doc, ['Neutral']);
    var ctx = canvas.ctx;
    ctx.drawImage(image['Walter_Pitts'], 0, 0);
  };
  //___________________________________________________________________________
  comment.Warren_McCulloch  = function() { var doc = HERE(function() {/*
Warren McCulloch
    */});
    html.Comment('McCulloch', doc, ['Neutral']);
    var ctx = canvas.ctx;
    ctx.drawImage(image['Warren_McCulloch'], 0, 0);
  };
  //___________________________________________________________________________
  comment.RLE  = function() { var doc = HERE(function() {/*
Research Laboratory of Electronics
    */});
    html.Comment('RLE', doc, ['Neutral']);
    var ctx = canvas.ctx;
    ctx.drawImage(image['RLE'], 0, 0);
  };

  //___________________________________________________________________________
  comment.Jonathan_Lettvin  = function() { var doc = HERE(function() {/*
Jonathan D. Lettvin
    */});
    html.Comment('Jonathan_Lettvin', doc, ['Neutral']);
    var ctx = canvas.ctx;
    ctx.drawImage(image['Jonathan_Lettvin'], 0, 0);
  };


  //###########################################################################
  speaker.Resting = function() {

    speaker.audible = false;

    speaker.context = new window.AudioContext();
 
    speaker.osc = speaker.context.createOscillator();
    speaker.osc.frequency.value = 3; //440;
    speaker.osc.type = "square";
    speaker.osc.connect(speaker.context.destination);
    speaker.osc.start(0);
 
    speaker.gain = speaker.context.createGain();
    speaker.volume = 0.50;
    speaker.gain.gain.value = speaker.volume;
    speaker.gain.connect(speaker.osc.frequency);

    speaker.context.suspend(0);   // Begins muted.
  };

  //___________________________________________________________________________
  speaker.Hear = function() {
    var mute = d.getElementById("mute");
    speaker.context.resume(0);
    mute.style.color = "red";
    mute.innerHTML = "Click to MUTE";
  };

  //___________________________________________________________________________
  speaker.Mute = function() {
    var mute = d.getElementById("mute");
    speaker.context.suspend(0);
    mute.style.color = "green";
    mute.innerHTML = "Click to HEAR";
  };

  //___________________________________________________________________________
  speaker.Toggle = function() {
    speaker.audible ^= true;
    speaker.audible ? speaker.Hear() : speaker.Mute();
  };

  //###########################################################################
  pushEvent(comment.Neutral);
  pushEvent(speaker.Resting);

//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
}).call(this, window, document);
  </script>
</head>
<body>
<!-- HTML FRAMEWORK <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< -->
<table id="main">

  <tr>
    <td width="50%">
      <table>
        <tr>
          <td id="part">
            <u><big><big id="Title"></big></big></u><br />
            <code id="Citation"></code>
          </td>
        </tr>
        <tr>
          <td id="part" width="50%">
            <big id="PartI_title"></big>
            <p id="PartI_body"></p>
          </td>

        </tr>
        <tr>
          <td id="part" id="part" width="50%" valign="top">
            <big id="PartII_title"></big>
            <p id="PartII_body"></p>
          </td>
        </tr>
      </table>
    </td><td valign="top" width="50%">
      <big id="Illustration"></big><br />
        <button id="mute" type="button" onclick="window.html.speaker.Toggle()" >
          Click to HEAR
        </button>
        simulated ganglion cell discharges.
      <table>
        <tr>
          <td height="255px" width="255px" align="left">
            <canvas id="illustration" width="255" height="255"></canvas><br />
            <b id="Caption"></b>
          </td>
        </tr>
        <tr>
          <td rowspan="2" width="50%">
            <big>Commentary</big><br />
            <p id="Commentary"></p>
          </td>
        </tr>
      </table>
    </td>
  </tr>


</table>
<!-- HTML FRAMEWORK >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> -->
</body>
</html>
